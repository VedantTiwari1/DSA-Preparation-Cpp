#include <vector>
#include <set>
#include <numeric>

using namespace std;

class Solution {
public:
    long long minimumCost(vector<int>& nums, int k, int dist) {
        int n = nums.size();
        long long current_sum = 0;
        multiset<int> low, high;

        // We need to pick k-1 elements from the window
        int target_size = k - 1;

        // Helper to balance the sets
        auto balance = [&]() {
            while (low.size() < target_size && !high.empty()) {
                int val = *high.begin();
                current_sum += val;
                low.insert(val);
                high.erase(high.begin());
            }
            while (low.size() > target_size) {
                int val = *low.rbegin();
                current_sum -= val;
                high.insert(val);
                low.erase(prev(low.end()));
            }
        };

        // Initial window: elements from index 1 to dist + 1
        for (int i = 1; i <= dist + 1; ++i) {
            high.insert(nums[i]);
        }
        balance();

        long long min_cost = current_sum;

        // Slide the window
        for (int i = 2; i <= n - dist - 1; ++i) {
            // Remove outgoing element nums[i-1]
            int out = nums[i - 1];
            if (low.find(out) != low.end()) {
                current_sum -= out;
                low.erase(low.find(out));
            } else {
                high.erase(high.find(out));
            }

            // Add incoming element nums[i + dist]
            if (i + dist < n) {
                int in = nums[i + dist];
                if (!low.empty() && in < *low.rbegin()) {
                    current_sum += in;
                    low.insert(in);
                } else {
                    high.insert(in);
                }
            }

            balance();
            min_cost = min(min_cost, current_sum);
        }

        return min_cost + nums[0];
    }
};
