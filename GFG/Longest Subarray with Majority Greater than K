class Solution {
public:
    int longestSubarray(vector<int>& arr, int k) {
        int n = arr.size();
        int prefixSum = 0;
        int maxLen = 0;
        
        // Map to store the first occurrence of each prefix sum
        // key: prefixSum, value: first index where it occurred
        unordered_map<int, int> mp;
        
        for (int i = 0; i < n; i++) {
            // Transform value
            prefixSum += (arr[i] > k) ? 1 : -1;
            
            // Case 1: If current sum is > 0, the whole array from 0 to i is valid
            if (prefixSum > 0) {
                maxLen = i + 1;
            } 
            // Case 2: We need to find the earliest point where (prefixSum - someValue) < 0
            // Actually, for a subarray ending at i to have sum > 0, 
            // we need prefixSum[i] - prefixSum[j] > 0 => prefixSum[i] > prefixSum[j].
            // The best way to maximize i - j is to find the smallest j where 
            // prefixSum[j] = prefixSum[i] - 1.
            else {
                if (mp.find(prefixSum - 1) != mp.end()) {
                    maxLen = max(maxLen, i - mp[prefixSum - 1]);
                }
            }
            
            // Only store the first occurrence of a prefixSum to maximize length
            if (mp.find(prefixSum) == mp.end()) {
                mp[prefixSum] = i;
            }
        }
        
        return maxLen;
    }
};
